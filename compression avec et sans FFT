from cmath import exp
from cmath import pi
import numpy as np
import matplotlib.pyplot as plt
image=plt.imread('C:\\Users\\Armance\\Pictures\\ele.png')
m=[[140,144,147,140,140,155,179,175],[144,152,140,147,140,148,167,179],[152,155,136,167,163,162,152,172],[168,145,156,160,152,155,136,160],[162,148,156,148,140,136,147,162],[147,167,140,155,155,140,136,162],[136,156,123,167,162,144,140,147],[148,155,136,155,152,147,147,136]]

## TFD et TCD2D
def fft(A):
    n=len(A)
    if n==1:
        return(A)
    wn=exp(-2*pi*1j/n)
    w=1
    A0=[A[2*k] for k in range(0,n//2)]
    A1=[A[2*k+1] for k in range(0,n//2)]
    Y0=fft(A0)
    Y1=fft(A1)
    Y=[0 for i in range(n)]
    for k in range(0,n//2):
        Y[k]=Y0[k]+w*Y1[k]
        Y[k+n//2]=Y0[k]-w*Y1[k]
        w=w*wn
    return(Y)

def ffti(B):
    n=len(B)
    conjB=[np.conj(i) for i in B]
    C=fft(conjB)
    conjC=[np.conj(i)/2 for i in C]
    return(conjC)
    
def sym(x):
    n=len(x)
    y=[0 for i in range(2*n)]
    for i in range(0,n):
        y[i]=x[i]
    for i in range(n,2*n):
        y[i]=x[2*n-i-1]
    return(y)
    
def coef(k):
    if k==0:
        return 1/(2**(1/2))
    return 1
    
def DCT(x):
    n=len(x) 
    y=sym(x)
    fy=fft(y)
    dfy=[(coef(k)*exp(-pi*1j*k/(2*n))*fy[k]/n).real for k in range(len(fy)//2)]
    return ( dfy )
            
def G(mat,u,y):
    n=len(mat)
    A=[mat[x][y] for x in range(n)]
    return ( DCT(A)[u] )
    
def F(mat,u,v):
    n=len(mat)
    A=[G(mat,u,y) for y in range(n)]
    return ( DCT(A)[v] )

def DCT2D(mat):
    n=len(mat)
    FFTmat=[[F(mat,u,v)*n/2 for v in range(n)] for u in range(n)]
    return( FFTmat )   


##Compression 

def quantification(m,s):
    n=len(m)
    mat=[[round(m[i][j]/(1+s*(1+i+j))) for j in range(n)] for i in range(n)]
    return(mat)

def dequantification(m,s):
    n=len(m)
    mat=[[m[i][j]*(1+s*(1+i+j)) for j in range(n)] for i in range(n)]
    return(mat)

def compression(mat,s) :
    passage=[[coef(j)*(np.sqrt(2/8))*np.cos(((2*i+1)*j*np.pi)/(2*8)) for j in range(8)] for i in range(8)]
    mattcd=DCT2D(m)
    mattcd2=dequantification(quantification(mattcd,s),s)
    return(np.round(np.dot(passage,np.dot(mattcd2,np.transpose(passage))))) 

def compression2(mat,s) :
    passage=[np.zeros(8) for i in range(8)]
    for i in range(8) :
        for j in range(8) :
            passage[i][j] = coef(j)*(np.sqrt(2/8))*np.cos(((2*i+1)*j*np.pi)/(2*8))
    mattcd=np.round(np.dot(np.transpose(passage),np.dot(mat,passage)))
    return(np.round(np.dot(passage,np.dot(dequantification(quantification(mattcd,s),s),np.transpose(passage)))))
    

#En se servant de la fct compression2 dans jpeg, ça marche. En se servant de la fct compression, ça tourne......
def jpeg(mat,s) :
    (n,m) = np.shape(mat) 
    mat_comp=np.copy(mat)
    n2=n//8
    m2=m//8 
    for i in range (n2) :
        for j in range(m2) :
            mat88=mat_comp[i*8:(i+1)*8,j*8:(j+1)*8]*255
            mat88_comp=compression2(mat88,s)
            mat_comp[i*8:(i+1)*8,j*8:(j+1)*8] = mat88_comp/255
    return(mat_comp)

def image_comprimee(mat,s) :
    mat_comp=np.copy(mat)
    (n,m,k)=np.shape(mat) 
    for l in range(3) :
        matl=mat[:,:,l]
        mat_comp[:,:,l]=jpeg(matl,s)
    plt.imshow(mat_comp)
    plt.show()
    return()
